<#
.SYNOPSIS
    Export all SITs (Entities) and their associated elements that define
    proximity="..." as well as the Entity-level patternsProximity.

.DESCRIPTION
    For each DLP Sensitive Information Type Rule Package:

    - Parses the XML rule pack.
    - For each <Entity> (SIT):
        * Outputs ONE ROW for the SIT itself (NodeType = 'Entity'),
          using the Entity's patternsProximity attribute (if present).
        * Finds ALL descendant nodes under that Entity that have a
          proximity="..." attribute (e.g. <Pattern>, <Match>, <Any>, etc.)
          and outputs ONE ROW PER such node.

    Output columns:
        RulePackName
        RulePackPublisher
        EntityId
        SitName
        NodeType          (Entity / Pattern / Match / Any / etc.)
        NodeIdRef         (idRef if present, e.g. Func_aba_routing)
        NodeMinMatches    (minMatches if present, e.g. on <Any>)
        NodeConfidence    (confidenceLevel if present, e.g. on <Pattern>)
        NodeProximity     (for Entity row: patternsProximity; for others: proximity)
#>

param(
    [string]$OutputPath = ".\All-SITs-EntityAndProximityNodes.csv"
)

<#Write-Host "Connecting to Purview / Compliance PowerShell (IPPS)..." -ForegroundColor Cyan

try {
    # Reuses an existing session if one is already established
    Connect-IPPSSession -ErrorAction Stop
}
catch {
    Write-Warning "Could not connect to IPP session automatically. Make sure you are connected before running the script."
    throw
}
#>
Write-Host "Retrieving DLP Sensitive Information Type rule packages..." -ForegroundColor Cyan
$rulePacks = Get-DlpSensitiveInformationTypeRulePackage

if (-not $rulePacks) {
    Write-Warning "No DLP Sensitive Information Type Rule Packages found."
    return
}

$results = @()

foreach ($rp in $rulePacks) {
    Write-Host "Processing RulePack: $($rp.Name)" -ForegroundColor Yellow

    $bytes = $rp.SerializedClassificationRuleCollection
    if (-not $bytes) {
        Write-Warning "  No SerializedClassificationRuleCollection for $($rp.Name). Skipping."
        continue
    }

    # Rule packs are stored as UTF-16 XML
    $xmlText = [System.Text.Encoding]::Unicode.GetString($bytes)

    # Load XML
    $xml = New-Object System.Xml.XmlDocument
    $xml.PreserveWhitespace = $false
    $xml.LoadXml($xmlText)

    # Get Entity & Resource nodes (ignore namespaces)
    $entityNodes   = $xml.SelectNodes("//*[local-name()='Entity']")
    $resourceNodes = $xml.SelectNodes("//*[local-name()='Resource']")

    # Build EntityId -> DisplayName lookup from Resources
    $nameLookup = @{}
    foreach ($res in $resourceNodes) {
        $idRefAttr = $res.Attributes['idRef']
        if (-not $idRefAttr) { continue }

        $idRef = $idRefAttr.Value

        # Default Name first, otherwise any Name
        $nameNode = $res.SelectSingleNode("*[local-name()='Name' and @default='true']")
        if (-not $nameNode) {
            $nameNode = $res.SelectSingleNode("*[local-name()='Name']")
        }

        $displayName = if ($nameNode) { $nameNode.InnerText } else { $null }
        if ($displayName) {
            $nameLookup[$idRef] = $displayName
        }
    }

    foreach ($entity in $entityNodes) {
        $idAttr = $entity.Attributes['id']
        if (-not $idAttr) { continue }

        $entityId = $idAttr.Value

        # Friendly SIT name
        $sitName = if ($nameLookup.ContainsKey($entityId)) {
            $nameLookup[$entityId]
        }
        else {
            "[Unknown Name] (EntityId: $entityId)"
        }

        # 1) Always output ONE ROW per Entity (SIT) using patternsProximity
        $patternsProximityAttr = $entity.Attributes['patternsProximity']
        $entityPatternsProximity = if ($patternsProximityAttr) { $patternsProximityAttr.Value } else { $null }

        $results += [PSCustomObject]@{
            RulePackName      = $rp.Name
            RulePackPublisher = $rp.Publisher
            EntityId          = $entityId
            SitName           = $sitName
            NodeType          = "Entity"
            NodeIdRef         = $null
            NodeMinMatches    = $null
            NodeConfidence    = $null
            NodeProximity     = $entityPatternsProximity
        }

        # 2) Now, for this Entity, find ALL descendant nodes with proximity="..."
        $proxNodes = $entity.SelectNodes(".//*[@proximity]")

        foreach ($pn in $proxNodes) {
            $proxAttr = $pn.Attributes['proximity']
            if (-not $proxAttr) { continue }

            $nodeProximity = $proxAttr.Value
            $nodeType      = $pn.LocalName

            # Optional extras for context on the child node
            $idRefAttr  = $pn.Attributes['idRef']
            $minAttr    = $pn.Attributes['minMatches']
            $confAttr   = $pn.Attributes['confidenceLevel']

            $nodeIdRef      = if ($idRefAttr) { $idRefAttr.Value } else { $null }
            $nodeMinMatches = if ($minAttr) { $minAttr.Value } else { $null }
            $nodeConfidence = if ($confAttr) { $confAttr.Value } else { $null }

            $results += [PSCustomObject]@{
                RulePackName      = $rp.Name
                RulePackPublisher = $rp.Publisher
                EntityId          = $entityId
                SitName           = $sitName
                NodeType          = $nodeType
                NodeIdRef         = $nodeIdRef
                NodeMinMatches    = $nodeMinMatches
                NodeConfidence    = $nodeConfidence
                NodeProximity     = $nodeProximity
            }
        }
    }
}

if ($results.Count -eq 0) {
    Write-Warning "No SIT entities or proximity attributes found to export."
}
else {
    Write-Host "Exporting $($results.Count) rows to CSV..." -ForegroundColor Green

    $results |
        Sort-Object SitName, RulePackName, EntityId, NodeType, NodeIdRef |
        Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8

    Write-Host "Export complete: $OutputPath" -ForegroundColor Green
}
